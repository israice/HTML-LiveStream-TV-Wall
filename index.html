<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LiveStream Wall</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }

    .container {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      height: 100%;
    }

    .video-wrapper {
      position: relative;
    }

    .hls-video {
      object-fit: cover;
      border: none;
      cursor: pointer;
      pointer-events: auto;
      display: block;
    }

    .overlay-image {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 75px;
      height: 75px;
      transform: translate(-50%, -50%);
      z-index: 9999;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container" id="video-container"></div>

  <script>
    const VIDEO_COUNT = 16;
    const container = document.getElementById('video-container');
    const overlayImages = [];
    const allVideos = [];

    const showOverlaysFor5Seconds = () => {
      overlayImages.forEach(img => img.style.display = 'block');
      setTimeout(() => {
        overlayImages.forEach(img => img.style.display = 'none');
      }, 5000);
    };

    const muteAllVideos = () => {
      allVideos.forEach(v => v.muted = true);
    };

    const initializeVideo = (video, source) => {
      if (Hls.isSupported()) {
        const hls = new Hls();
        hls.loadSource(source);
        hls.attachMedia(video);
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          video.play().catch(() => {});
        });
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = source;
        video.addEventListener('loadedmetadata', () => {
          video.play().catch(() => {});
        });
      }
    };

    const renderVideos = (links) => {
      const sources = links.slice(0, VIDEO_COUNT);
      while (sources.length < VIDEO_COUNT) {
        sources.push(...links.slice(0, VIDEO_COUNT - sources.length));
      }

      const columns = Math.ceil(Math.sqrt(VIDEO_COUNT));
      const rowHeight = 100 / Math.ceil(VIDEO_COUNT / columns);
      const columnWidth = 100 / columns;

      sources.forEach((src, index) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'video-wrapper';
        wrapper.style.width = `${columnWidth}%`;
        wrapper.style.height = `${rowHeight}%`;

        const video = document.createElement('video');
        video.className = 'hls-video';
        video.controls = true;
        video.autoplay = true;
        video.muted = true;
        video.style.width = '100%';
        video.style.height = '100%';
        allVideos.push(video);

        const image = document.createElement('img');
        image.className = 'overlay-image';
        image.src = 'image.webp';
        image.alt = `Overlay ${index}`;
        overlayImages.push(image);

        video.addEventListener('click', async (event) => {
          event.preventDefault();
          event.stopPropagation();

          try {
            const isFullscreen =
              document.fullscreenElement === video ||
              document.webkitFullscreenElement === video ||
              document.mozFullScreenElement === video ||
              document.msFullscreenElement === video;

            if (!isFullscreen) {
              video.muted = false;
              if (video.requestFullscreen) await video.requestFullscreen();
              else if (video.webkitRequestFullscreen) await video.webkitRequestFullscreen();
              else if (video.mozRequestFullScreen) await video.mozRequestFullScreen();
              else if (video.msRequestFullscreen) await video.msRequestFullscreen();
            } else {
              video.muted = true;

              const exitFullscreen = () => {
                if (document.exitFullscreen) return document.exitFullscreen();
                else if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
                else if (document.msExitFullscreen) return document.msExitFullscreen();
              };

              await exitFullscreen();

              const waitUntilExited = () => {
                return new Promise(resolve => {
                  const check = () => {
                    const fs =
                      document.fullscreenElement ||
                      document.webkitFullscreenElement ||
                      document.mozFullScreenElement ||
                      document.msFullscreenElement;
                    if (!fs) resolve();
                    else setTimeout(check, 50);
                  };
                  check();
                });
              };

              await waitUntilExited();

              showOverlaysFor5Seconds();
            }
          } catch (e) {
            console.error('Fullscreen toggle failed', e);
          }
        });

        wrapper.appendChild(video);
        wrapper.appendChild(image);
        container.appendChild(wrapper);

        initializeVideo(video, src);
      });
    };

    // Слушаем системный выход из фуллскрина
    const handleFullscreenChange = () => {
      const fsElement =
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement;

      if (!fsElement) {
        muteAllVideos();
        showOverlaysFor5Seconds();
      }
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);

    fetch('connected.txt')
      .then(r => r.text())
      .then(text => {
        const links = text.split('\n').map(l => l.trim()).filter(Boolean);
        renderVideos(links);
      })
      .catch(err => {
        alert('Failed to load connected.txt: ' + err.message);
      });
  </script>
</body>
</html>
